<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:int="http://www.springframework.org/schema/integration"
	xmlns:int-file="http://www.springframework.org/schema/integration/file"
	xmlns:int-jpa="http://www.springframework.org/schema/integration/jpa"
	xmlns:jdbc="http://www.springframework.org/schema/jdbc"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:rabbit="http://www.springframework.org/schema/rabbit"
	xsi:schemaLocation="http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd
		http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file-4.1.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.1.xsd
		http://www.springframework.org/schema/integration/jpa http://www.springframework.org/schema/integration/jpa/spring-integration-jpa-4.1.xsd
		http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration-4.1.xsd
		http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd">

	
	<import resource="classpath:/META-INF/spring/integration/hibernate-context.xml" />
	
	<!-- ****************************************
	****************** COMMON UTILITY ****************** 
	*********************************************-->
	<bean id="commonUtility" class="common.CommonUtility" />
	
	
	<!-- ****************************************
	****************** GRABBER ****************** 
	*********************************************-->
	<int:channel id="grabberChOut" fixed-subscriber="true"/>
	<int:channel id="transformerChIn" fixed-subscriber="true" />

	<bean id="xmltvGrabber" class="xmltv.grabber.XMLTVGrabber" />
	
	<int:inbound-channel-adapter ref="xmltvGrabber" method="doGrabbing"
		channel="grabberChOut" id="grabberInbound">
		<int:poller max-messages-per-poll="1" cron="0 	*  *  *   *  ?  " />
		<!-- sec m h dm m dw -->
	</int:inbound-channel-adapter>

	<int-file:outbound-channel-adapter id="grabberOutbound"
		channel="grabberChOut" directory="file:xmltv_cap"
		auto-create-directory="true" mode="REPLACE"
		temporary-file-suffix="writing" delete-source-files="true"
		>
	</int-file:outbound-channel-adapter>

	<!-- ****************************************
	****************** TRANSFORMER ****************** 
	*********************************************-->
	<int:channel id="transformerChOut" fixed-subscriber="true" />

	<bean id="xmltvTransformerBean" class="xmltv.transformer.XMLTVTransformer" />
	<bean id="xmltvFileComparator" class="xmltv.grabber.CustomFileComparator" />
	<bean id="eventCreator" class="xmltv.transformer.EventCreator"/>
	
	<int-file:inbound-channel-adapter id="filePollerInbound"
		directory="file:xmltv_cap" channel="transformerChIn" auto-startup="true"
		comparator="xmltvFileComparator"
		filename-regex="xmltvDump_[0-9][0-9][0-9][0-9]_[0-9][0-9]_[0-9][0-9]_[0-9][0-9]_[0-9][0-9]_[0-9][0-9]\.xml" >
		<int:poller fixed-rate="10000" />
	</int-file:inbound-channel-adapter>

	<int:transformer id="transformerXmlToPojo"
		ref="xmltvTransformerBean" input-channel="transformerChIn"
		method="transform" output-channel="transformerChOut" />

	<int:service-activator id="transformerSA"
		input-channel="transformerChOut" ref="eventCreator" method="createEvents"
		requires-reply="false">
	</int:service-activator>

	<!-- ****************************************
	****************** EVENT POLLER ****************** 
	*********************************************-->
	<int:channel id="eventPollerChOut" fixed-subscriber="true" />

	<bean id="eventPoller" class="eventproducer.EventProducerPoller" />
	<bean id="eventPollerReply" class="eventproducer.EventProducerPollerReply"/>
	
	<int:inbound-channel-adapter id="eventPollerInbound"
		ref="eventPoller" method="askForEvents"
		channel="eventPollerChOut">
		<int:poller fixed-rate="5000" />
	</int:inbound-channel-adapter>
	
	<int:outbound-channel-adapter id="eventPollerOutbound"
	channel="eventPollerChOut"
	ref="eventPollerReply" method="receive">
	</int:outbound-channel-adapter>
	
<!-- 	<int:service-activator id="eventPollerSA"
		input-channel="eventPollerChIn" ref="eventPoller" method="askForEvents"
		requires-reply="false" >
	</int:service-activator> -->
	
	
	
	<!-- ****************************************
	****************** PERSISTENCE ****************** 
	*********************************************-->
	<int:channel id="eventCreatorChIn" fixed-subscriber="true" />
	<int:channel id="closerEventChIn" fixed-subscriber="true" />
	<int:channel id="getAllEventChIn" fixed-subscriber="true" />

	<int:gateway id="eventServiceGateway"
		service-interface="eventmanager.EventService"
		default-request-timeout="5000" default-reply-timeout="5000">
		<int:method name="createMultipleEvents"
			request-channel="eventCreatorChIn"/>
		<int:method name="getCloserEvents" 
			request-channel="closerEventChIn" />
		<int:method name="getAllEvents" request-channel="getAllEventChIn" />
	</int:gateway>

	<int-jpa:updating-outbound-gateway id="eventCreatorOutbound"
		entity-manager-factory="entityManagerFactory"
		request-channel="eventCreatorChIn">
		<int-jpa:transactional transaction-manager="transactionManager" />
	</int-jpa:updating-outbound-gateway>

	<int-jpa:retrieving-outbound-gateway id="getCloserEventsOutbound"
		entity-manager-factory="entityManagerFactory"
		request-channel="closerEventChIn" jpa-query="select e from Event e"
		requires-reply="false" reply-channel="closerEventChOut">
		<!-- jpa-query="select e from Event e where e.end > :now order by e.start asc"> -->
		 <!-- <int-jpa:parameter name="now" type="java.util.Date" /> -->
		<!-- Seleccionar los eventos tal que la fecha de su final sea mayor que la fecha actual
				y ordenarlos tal que los primeros que aparezcan sean los que antes empiecen -->
	</int-jpa:retrieving-outbound-gateway>

	<!-- ****************************************
	****************** EVENT PRODUCTOR ****************** 
	*********************************************-->
<!-- 	<bean id="rabbitConnectionFactoryBean" class="com.rabbitmq.client.ConnectionFactory">
	<property name="host" 			value="localhost" />
	<property name="username" 		value="user" />
	<property name="password" 		value="userp" />
	<property name="virtualHost" 	value="/" />
	<property name="port" 			value="5672"/>
	</bean> -->
    <!-- <rabbit:template id="amqpTemplate" connection-factory="connectionFactory"/> -->
    <!-- <rabbit:admin connection-factory="connectionFactory" /> -->
    
    <rabbit:connection-factory id="connectionFactory" 
    	host="localhost" 
    	virtual-host="/" 
    	username="user" 
    	password="userp" 
    	port="5672" />

    <rabbit:topic-exchange name="amq.topic"></rabbit:topic-exchange>
    
	<!-- Spring AMQP template - Creates a bean which can send a message to the topicExchange-->
	<rabbit:template id="amqpTemplate" 
		connection-factory="connectionFactory" 
		exchange="amq.topic" />
	<!-- Spring AMQP Admin -->
	<rabbit:admin connection-factory="connectionFactory" />
    
	<int:channel id="closerEventChOut" >
		<int:queue capacity="10"/>
	</int:channel>
	<bean id="eventProducerPublisher" class="eventproducer.EventProducerPublisher" />
	
	<int:outbound-channel-adapter id="eventPublisherOut"
		ref="eventProducerPublisher" method="publishTopics"
		channel="closerEventChOut">
		<int:poller fixed-rate="1000"/>
	</int:outbound-channel-adapter>


	<!-- ****************************************
	****************** PERSISTENCE TEST ****************** 
	*********************************************-->
	
	<int-jpa:retrieving-outbound-gateway id="getAllEventsOutbound"
		entity-manager-factory="entityManagerFactory"
		request-channel="getAllEventChIn" jpa-query="select e from Event e">
	</int-jpa:retrieving-outbound-gateway>
	
	<!-- ****************************************
	****************** MQTT CLIENT TEST ****************** 
	*********************************************-->
	
	<bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
    <property name="corePoolSize" value="5" />
    <property name="maxPoolSize" value="10" />
    <property name="queueCapacity" value="25" />
	</bean>
	<bean id="taskExecutorClient" class="eventproducer.TaskExecutorMQTTClient" 
		scope="prototype">
	    <constructor-arg ref="taskExecutor" />
	    
	</bean>
</beans>
